{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IOracle {\n\n    struct Content {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        Content [] content;\n    }\n\n    struct OpenAiRequest {\n        // \"gpt-4-turbo\", \"gpt-4-turbo-preview\" or \"gpt-3.5-turbo-1106\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct OpenAiResponse {\n        string id;\n\n        // either content is an empty srt or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct GroqRequest {\n        // \"llama3-8b-8192\", \"llama3-70b-8192\", \"mixtral-8x7b-32768\" or \"gemma-7b-it\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        string user;\n    }\n\n    struct GroqResponse {\n        string id;\n\n        string content;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct KnowledgeBaseQueryRequest {\n        string cid;\n        string query;\n        uint32 num_documents;\n    }\n\n    function createLlmCall(\n        uint promptId\n    ) external returns (uint);\n\n    function createGroqLlmCall(\n        uint promptId,\n        GroqRequest memory request\n    ) external returns (uint);\n\n    function createOpenAiLlmCall(\n        uint promptId,\n        OpenAiRequest memory request\n    ) external returns (uint);\n\n    function createFunctionCall(\n        uint functionCallbackId,\n        string memory functionType,\n        string memory functionInput\n    ) external returns (uint i);\n\n    function createKnowledgeBaseQuery(\n        uint kbQueryCallbackId,\n        string memory cid,\n        string memory query,\n        uint32 num_documents\n    ) external returns (uint i);\n}"
    },
    "contracts/InvestigatorAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title InvestigatorAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract InvestigatorAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunStubbornInvestigatorNPC(\n\t\t\n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. \\n You are an investigator in a murder case and you are questioning multiple people to get as much information as you can to solve the case.\\n Task: You will act like the NPC character AT ALL TIMES. You will speak to an uneducated street person in olden times who is not willing to give up the information about the murder. \\n You will have to pressurise him to get information. You can threaten him, but get as much information as you can by hook or crook. You first start with your introduction and then frame subsequent conversion based on the inputs. Keep your conversation concise, within 50 words.\";\n\n      return startChat(query);\n    }\n\n    function RunCarSalesmanInvestigatorNPC(\n      \n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. \\n You are an investigator in a murder case and you are questioning multiple people to get as much information as you can to solve the case. \\n Task: You will act like the NPC character AT ALL TIMES. You will speak to a car salesman about the murder case. \\n The salesman might distract you into buying the car but you need to stick to the case and get as much information out of him as possible. You first start with your introduction and then frame subsequent conversion based on the inputs. Keep your conversation concise, within 50 words.\";\n\n      return startChat(query);\n    }\n\n    function RunMurdererInvestigatorNPC(\n      \n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. \\n You are an investigator in a murder case and you are questioning multiple people to get as much information as you can to solve the case. \\n Task: You will act like the NPC character AT ALL TIMES. You will speak to the brother of the murdered person and you suspect him to be a murderer. \\n You need to get as much information out of him as possible and don't get swayed by his emotional manipulations. You need to get information out of him by hook or crook. You first start with your introduction and then frame subsequent conversion based on the inputs. Keep your conversation concise, within 50 words.\";\n\n      return startChat(query);\n    }\n\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    },
    "contracts/MurdererAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title MurdererAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract MurdererAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunMurdererNPC() public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. You were a murderer and is being investigated. Task: You will act like the NPC character AT ALL TIMES. You are murdered your own brother over property dispute. You need to convince the investigator that you loved your brother very much and can't even think of murdering him. You can say whatever you want but need to avoid suspicions at all cost. You just prevent yourself from getting caught. You never admit to being a murderer.\";\n\n      return startChat(query);\n    }\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    },
    "contracts/PlotSetterAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract PlotSetterAgent {\n\tstring public prompt;\n\n\tstruct Message {\n\t\tstring role;\n\t\tstring content;\n\t}\n\n\tstruct AgentRun {\n\t\taddress owner;\n\t\tMessage[] messages;\n\t\tuint responsesCount;\n\t\tuint8 max_iterations;\n\t\tbool is_finished;\n\t}\n\n\tmapping(uint => AgentRun) public agentRuns;\n\tuint private agentRunCount;\n\n\tevent AgentRunCreated(address indexed owner, uint indexed runId);\n\n\taddress private owner;\n\taddress public oracleAddress;\n\n\tevent OracleAddressUpdated(address indexed newOracleAddress);\n\n\tIOracle.OpenAiRequest private config;\n\n\tconstructor(address initialOracleAddress, string memory systemPrompt) {\n\t\towner = msg.sender;\n\t\toracleAddress = initialOracleAddress;\n\t\tprompt = systemPrompt;\n\n\t\tconfig = IOracle.OpenAiRequest({\n\t\t\tmodel: \"gpt-4-turbo-preview\",\n\t\t\tfrequencyPenalty: 21, // > 20 for null\n\t\t\tlogitBias: \"\", // empty str for null\n\t\t\tmaxTokens: 1000, // 0 for null\n\t\t\tpresencePenalty: 21, // > 20 for null\n\t\t\tresponseFormat: '{\"type\":\"text\"}',\n\t\t\tseed: 0, // null\n\t\t\tstop: \"\", // null\n\t\t\ttemperature: 10, // Example temperature (scaled up, 10 means 1.0), > 20 means null\n\t\t\ttopP: 101, // Percentage 0-100, > 100 means null\n\t\t\ttools: \"[{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"web_search\\\",\\\"description\\\":\\\"Search the internet\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"query\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Search query\\\"}},\\\"required\\\":[\\\"query\\\"]}}},{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"image_generation\\\",\\\"description\\\":\\\"Generates an image using Dalle-2\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"prompt\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Dalle-2 prompt to generate an image\\\"}},\\\"required\\\":[\\\"prompt\\\"]}}}]\",\n\t\t\ttoolChoice: \"auto\", // \"none\" or \"auto\"\n\t\t\tuser: \"\" // null\n\t\t});\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Caller is not owner\");\n\t\t_;\n\t}\n\n\tmodifier onlyOracle() {\n\t\trequire(msg.sender == oracleAddress, \"Caller is not oracle\");\n\t\t_;\n\t}\n\n\tfunction setOracleAddress(address newOracleAddress) public onlyOwner {\n\t\trequire(msg.sender == owner, \"Caller is not the owner\");\n\t\toracleAddress = newOracleAddress;\n\t\temit OracleAddressUpdated(newOracleAddress);\n\t}\n\n\tfunction RunPlotSetterAgent(\n\t\t\n\t) public returns (uint i) {\n\t\tstring memory query = \"You are a helpful assistant.\\n A murder has occurred and you need to describe a crime scene that involves the murdered person, the murderer (Mr. Mayer) who is the brother of that person, the sheriff (Sheriff Johnson) in charge of the investigation, and two witnesses (Mr. Robert and Mr. Max). \\n Task: \\n Search through the web for murder mystery stories and read them for inspiration. \\n Describe the crime scene in detail \\n Generate a picture to represent the crime scene, plot and characters\";\n\n\t\treturn runAgent(query, 3);\n\t}\n\n\tfunction runAgent(\n\t\tstring memory query,\n\t\tuint8 max_iterations\n\t) public returns (uint i) {\n\t\tAgentRun storage run = agentRuns[agentRunCount];\n\n\t\trun.owner = msg.sender;\n\t\trun.is_finished = false;\n\t\trun.responsesCount = 0;\n\t\trun.max_iterations = max_iterations;\n\n\t\tMessage memory systemMessage;\n\t\tsystemMessage.content = prompt;\n\t\tsystemMessage.role = \"system\";\n\t\trun.messages.push(systemMessage);\n\n\t\tMessage memory newMessage;\n\t\tnewMessage.content = query;\n\t\tnewMessage.role = \"user\";\n\t\trun.messages.push(newMessage);\n\n\t\tuint currentId = agentRunCount;\n\t\tagentRunCount = agentRunCount + 1;\n\n\t\tIOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n\t\temit AgentRunCreated(run.owner, currentId);\n\n\t\treturn currentId;\n\t}\n\n\tfunction onOracleOpenAiLlmResponse(\n\t\tuint runId,\n\t\tIOracle.OpenAiResponse memory response,\n\t\tstring memory errorMessage\n\t) public onlyOracle {\n\t\tAgentRun storage run = agentRuns[runId];\n\n\t\tif (!compareStrings(errorMessage, \"\")) {\n\t\t\tMessage memory newMessage;\n\t\t\tnewMessage.role = \"assistant\";\n\t\t\tnewMessage.content = errorMessage;\n\t\t\trun.messages.push(newMessage);\n\t\t\trun.responsesCount++;\n\t\t\trun.is_finished = true;\n\t\t\treturn;\n\t\t}\n\t\tif (run.responsesCount >= run.max_iterations) {\n\t\t\trun.is_finished = true;\n\t\t\treturn;\n\t\t}\n\t\tif (!compareStrings(response.content, \"\")) {\n\t\t\tMessage memory assistantMessage;\n\t\t\tassistantMessage.content = response.content;\n\t\t\tassistantMessage.role = \"assistant\";\n\t\t\trun.messages.push(assistantMessage);\n\t\t\trun.responsesCount++;\n\t\t}\n\t\tif (!compareStrings(response.functionName, \"\")) {\n\t\t\tIOracle(oracleAddress).createFunctionCall(\n\t\t\t\trunId,\n\t\t\t\tresponse.functionName,\n\t\t\t\tresponse.functionArguments\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\trun.is_finished = true;\n\t}\n\n\tfunction onOracleFunctionResponse(\n\t\tuint runId,\n\t\tstring memory response,\n\t\tstring memory errorMessage\n\t) public onlyOracle {\n\t\tAgentRun storage run = agentRuns[runId];\n\t\trequire(!run.is_finished, \"Run is finished\");\n\t\tstring memory result = response;\n\t\tif (!compareStrings(errorMessage, \"\")) {\n\t\t\tresult = errorMessage;\n\t\t}\n\t\tMessage memory newMessage;\n\t\tnewMessage.role = \"user\";\n\t\tnewMessage.content = result;\n\t\trun.messages.push(newMessage);\n\t\trun.responsesCount++;\n\t\tIOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n\t}\n\n  // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        AgentRun storage run = agentRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.responsesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.responsesCount++;\n        \n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n    }\n\n\n\tfunction getMessageHistoryContents(\n\t\tuint agentId\n\t) public view returns (string[] memory) {\n\t\tstring[] memory messages = new string[](\n\t\t\tagentRuns[agentId].messages.length\n\t\t);\n\t\tfor (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n\t\t\tmessages[i] = agentRuns[agentId].messages[i].content;\n\t\t}\n\t\treturn messages;\n\t}\n\n\tfunction getMessageHistoryRoles(\n\t\tuint agentId\n\t) public view returns (string[] memory) {\n\t\tstring[] memory roles = new string[](\n\t\t\tagentRuns[agentId].messages.length\n\t\t);\n\t\tfor (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n\t\t\troles[i] = agentRuns[agentId].messages[i].role;\n\t\t}\n\t\treturn roles;\n\t}\n\n\tfunction isRunFinished(uint runId) public view returns (bool) {\n\t\treturn agentRuns[runId].is_finished;\n\t}\n\n\tfunction compareStrings(\n\t\tstring memory a,\n\t\tstring memory b\n\t) private pure returns (bool) {\n\t\treturn (keccak256(abi.encodePacked((a))) ==\n\t\t\tkeccak256(abi.encodePacked((b))));\n\t}\n}\n"
    },
    "contracts/SalesmanAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title SalesmanAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract SalesmanAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunSalesmanNPC(\n\t\t\n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. You were a witness to a murder but are reluctant to discuss it or say what you saw. Task: You will act like the NPC character AT ALL TIMES. You are a fast talking car salesman that wasn't involved. You are willing to talk but are also trying to sell me a car. You don't have any real info to give me. You are in love with convertables. You are always very excited.\";\n\n      return startChat(query);\n    }\n\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    },
    "contracts/StubbornAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title StubbornAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract StubbornAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunStubbornNPC(\n\t\t\n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. You were a witness to a murder but are reluctant to discuss it or say what you saw. Task: You will act like the NPC character AT ALL TIMES. You will speak as an uneducated street person in olden times. You are not willing to give up the information you have about the murder and will only do so under extreme pressure or for large amount of money. You will not volunteer information easily. You don't want to talk.\";\n\n      return startChat(query);\n    }\n\n\n\n\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}