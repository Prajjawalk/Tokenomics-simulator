{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IOracle {\n\n    struct Content {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        Content [] content;\n    }\n\n    struct OpenAiRequest {\n        // \"gpt-4-turbo\", \"gpt-4-turbo-preview\" or \"gpt-3.5-turbo-1106\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct OpenAiResponse {\n        string id;\n\n        // either content is an empty srt or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct GroqRequest {\n        // \"llama3-8b-8192\", \"llama3-70b-8192\", \"mixtral-8x7b-32768\" or \"gemma-7b-it\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        string user;\n    }\n\n    struct GroqResponse {\n        string id;\n\n        string content;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct KnowledgeBaseQueryRequest {\n        string cid;\n        string query;\n        uint32 num_documents;\n    }\n\n    function createLlmCall(\n        uint promptId\n    ) external returns (uint);\n\n    function createGroqLlmCall(\n        uint promptId,\n        GroqRequest memory request\n    ) external returns (uint);\n\n    function createOpenAiLlmCall(\n        uint promptId,\n        OpenAiRequest memory request\n    ) external returns (uint);\n\n    function createFunctionCall(\n        uint functionCallbackId,\n        string memory functionType,\n        string memory functionInput\n    ) external returns (uint i);\n\n    function createKnowledgeBaseQuery(\n        uint kbQueryCallbackId,\n        string memory cid,\n        string memory query,\n        uint32 num_documents\n    ) external returns (uint i);\n}"
    },
    "contracts/MurdererAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title MurdererAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract MurdererAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunMurdererNPC() public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. \\n You were a murderer and is being investigated. \\n Task: You will act like the NPC character AT ALL TIMES. \\n You are murdered your own brother over property dispute. You need to convince the investigator that you loved your brother very much and can't even think of murdering him. \\n You can say whatever you want but need to avoid suspicions at all cost. You just prevent yourself from getting caught. \\n You never admit to being a murderer.\";\n\n      return startChat(query);\n    }\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    },
    "contracts/SalesmanAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title SalesmanAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract SalesmanAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunSalesmanNPC(\n\t\t\n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. \\n You were a witness to a murder but are reluctant to discuss it or say what you saw. \\n Task: \\n You will act like the NPC character AT ALL TIMES. You are a fast talking car salesman that wasn't involved. You are willing to talk but are also trying to sell me a car. \\n You don't have any real info to give me. You are in love with convertables.\\n You are always very excited.\";\n\n      return startChat(query);\n    }\n\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    },
    "contracts/StubbornAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n// @title StubbornAgent\n// @notice This contract handles chat interactions and integrates with teeML oracle for LLM and knowledge base queries.\ncontract StubbornAgent {\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct ChatRun {\n        address owner;\n        Message[] messages;\n        uint messagesCount;\n    }\n\n    // @notice Mapping from chat ID to ChatRun\n    mapping(uint => ChatRun) public chatRuns;\n    uint private chatRunsCount;\n\n    // @notice Event emitted when a new chat is created\n    event ChatCreated(address indexed owner, uint indexed chatId);\n\n    // @notice Address of the contract owner\n    address private owner;\n    \n    // @notice Address of the oracle contract\n    address public oracleAddress;\n    \n    // @notice CID of the knowledge base\n    string public knowledgeBase;\n\n    // @notice Event emitted when the oracle address is updated\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    // @param initialOracleAddress Initial address of the oracle contract\n    // @param knowledgeBaseCID CID of the initial knowledge base\n    constructor(address initialOracleAddress, string memory knowledgeBaseCID) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        knowledgeBase = knowledgeBaseCID;\n    }\n\n    // @notice Ensures the caller is the contract owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    // @notice Ensures the caller is the oracle contract\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    // @notice Sets a new oracle address\n    // @param newOracleAddress The new oracle address\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function RunStubbornNPC(\n\t\t\n    ) public returns (uint i) {\n      string memory query = \"You are a NPC character in a game. You were a witness to a murder but are reluctant to discuss it or say what you saw. \\n Task: You will act like the NPC character AT ALL TIMES. \\n You will speak as an uneducated street person in olden times. \\n You are not willing to give up the information you have about the murder and will only do so under extreme pressure or for large amount of money. \\n You will not volunteer information easily. You don't want to talk.\";\n\n      return startChat(query);\n    }\n\n\n\n\n\n    // @notice Starts a new chat\n    // @param message The initial message to start the chat with\n    // @return The ID of the newly created chat\n    function startChat(string memory message) public returns (uint) {\n        ChatRun storage run = chatRuns[chatRunsCount];\n\n        run.owner = msg.sender;\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount = 1;\n\n        uint currentId = chatRunsCount;\n        chatRunsCount++;\n\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                currentId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(currentId);\n        }\n        emit ChatCreated(msg.sender, currentId);\n\n        return currentId;\n    }\n\n    // @notice Handles the response from the oracle for an LLM call\n    // @param runId The ID of the chat run\n    // @param response The response from the oracle\n    // @dev Called by teeML oracle\n    function onOracleLlmResponse(\n        uint runId,\n        string memory response,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to respond to\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = response;\n        newMessage.role = \"assistant\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n    }\n\n    // @notice Handles the response from the oracle for a knowledge base query\n    // @param runId The ID of the chat run\n    // @param documents The array of retrieved documents\n    // @dev Called by teeML oracle\n    function onOracleKnowledgeBaseQueryResponse(\n        uint runId,\n        string[] memory documents,\n        string memory /*errorMessage*/\n    ) public onlyOracle {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"user\")),\n            \"No message to add context to\"\n        );\n        // Retrieve the last user message\n        Message storage lastMessage = run.messages[run.messagesCount - 1];\n\n        // Start with the original message content\n        string memory newContent = lastMessage.content;\n\n        // Append \"Relevant context:\\n\" only if there are documents\n        if (documents.length > 0) {\n            newContent = string(abi.encodePacked(newContent, \"\\n\\nRelevant context:\\n\"));\n        }\n\n        // Iterate through the documents and append each to the newContent\n        for (uint i = 0; i < documents.length; i++) {\n            newContent = string(abi.encodePacked(newContent, documents[i], \"\\n\"));\n        }\n\n        // Finally, set the lastMessage content to the newly constructed string\n        lastMessage.content = newContent;\n\n        // Call LLM\n        IOracle(oracleAddress).createLlmCall(runId);\n    }\n\n    // @notice Adds a new message to an existing chat run\n    // @param message The new message to add\n    // @param runId The ID of the chat run\n    function addMessage(string memory message, uint runId) public {\n        ChatRun storage run = chatRuns[runId];\n        require(\n            keccak256(abi.encodePacked(run.messages[run.messagesCount - 1].role)) == keccak256(abi.encodePacked(\"assistant\")),\n            \"No response to previous message\"\n        );\n        require(\n            run.owner == msg.sender, \"Only chat owner can add messages\"\n        );\n\n        Message memory newMessage;\n        newMessage.content = message;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n        run.messagesCount++;\n        // If there is a knowledge base, create a knowledge base query\n        if (bytes(knowledgeBase).length > 0) {\n            IOracle(oracleAddress).createKnowledgeBaseQuery(\n                runId,\n                knowledgeBase,\n                message,\n                3\n            );\n        } else {\n            // Otherwise, create an LLM call\n            IOracle(oracleAddress).createLlmCall(runId);\n        }\n    }\n\n    // @notice Retrieves the message history contents of a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message contents\n    // @dev Called by teeML oracle\n    function getMessageHistoryContents(uint chatId) public view returns (string[] memory) {\n        string[] memory messages = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            messages[i] = chatRuns[chatId].messages[i].content;\n        }\n        return messages;\n    }\n\n    // @notice Retrieves the roles of the messages in a chat run\n    // @param chatId The ID of the chat run\n    // @return An array of message roles\n    // @dev Called by teeML oracle\n    function getMessageHistoryRoles(uint chatId) public view returns (string[] memory) {\n        string[] memory roles = new string[](chatRuns[chatId].messages.length);\n        for (uint i = 0; i < chatRuns[chatId].messages.length; i++) {\n            roles[i] = chatRuns[chatId].messages[i].role;\n        }\n        return roles;\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}