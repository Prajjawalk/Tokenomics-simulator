{
  "language": "Solidity",
  "sources": {
    "contracts/CommunityAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract CommunityAgent {\n\n    string public prompt;\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct AgentRun {\n        address owner;\n        Message[] messages;\n        uint responsesCount;\n        uint8 max_iterations;\n        bool is_finished;\n    }\n\n    mapping(uint => AgentRun) public agentRuns;\n    uint private agentRunCount;\n\n    event AgentRunCreated(address indexed owner, uint indexed runId);\n\n    address private owner;\n    address public oracleAddress;\n\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    IOracle.OpenAiRequest private config;\n\n    constructor(\n        address initialOracleAddress,         \n        string memory systemPrompt\n    ) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        prompt = systemPrompt;\n\n        config = IOracle.OpenAiRequest({\n            model : \"gpt-4-turbo-preview\",\n            frequencyPenalty : 21, // > 20 for null\n            logitBias : \"\", // empty str for null\n            maxTokens : 1000, // 0 for null\n            presencePenalty : 21, // > 20 for null\n            responseFormat : \"{\\\"type\\\":\\\"text\\\"}\",\n            seed : 0, // null\n            stop : \"\", // null\n            temperature : 10, // Example temperature (scaled up, 10 means 1.0), > 20 means null\n            topP : 101, // Percentage 0-100, > 100 means null\n            tools : \"[{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"web_search\\\",\\\"description\\\":\\\"Search the internet\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"query\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Search query\\\"}},\\\"required\\\":[\\\"query\\\"]}}},{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"image_generation\\\",\\\"description\\\":\\\"Generates an image using Dalle-2\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"prompt\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Dalle-2 prompt to generate an image\\\"}},\\\"required\\\":[\\\"prompt\\\"]}}}]\",\n            toolChoice : \"auto\", // \"none\" or \"auto\"\n            user : \"\" // null\n        });\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function reactionToNewDevelopment(\n      string memory projectName,\n      string memory projectDescription,\n      string memory totalSupply,\n      string memory tokenPrice,\n      string memory consensus,\n      string memory circulatingSupply,\n      string memory communitySize,\n      string memory marketCap,\n      string memory tradingVolume,\n      string memory priceVolatility,\n      string memory historicalPriceTrends,\n      string memory holderDistribution,\n      string memory burnRate,\n      string memory inflation,\n      string memory utility,\n      string memory ecosystemSize,\n      string memory partnerships,\n      string memory regulations,\n      string memory roadmap,\n      string memory developments\n    ) public returns (uint i) {\n      string memory query = string.concat(\n        \"You are a helpful assistant who helps with the community's reactions to every new development of the blockchain protocol. You need to behave in a way any general community member would behave given the information related to the protocol and the current market sentiments. \",\n        \"\\n\",\n        \"I will give you the following information - \\n\",\n        \"Name of the ICO project: \",\n        projectName,\n        \"\\n\",\n        \"Project description: \",\n        projectDescription,\n        \"\\n\",\n        \"The token total supply: \",\n        totalSupply,\n        \"\\n\",\n        \"Token price: \",\n\t\t\t  tokenPrice,\n        \"\\n\",\n        \"The token consensus: \",\n        consensus,\n        \"\\n\",\n        \"The token circulating supply in exchange: \",\n        circulatingSupply,\n        \"\\n\",\n        \"The token community size: \",\n        communitySize,\n        \"\\n\",\n        \"The token market cap: \",\n        marketCap,\n        \"\\n\",\n        \"Trading volume: \",\n        tradingVolume,\n        \"\\n\",\n        \"Price volatility: \",\n        priceVolatility,\n        \"\\n\",\n        \"Historical price trends: \",\n        historicalPriceTrends,\n        \"\\n\",\n        \"Holder distribution: \",\n        holderDistribution,\n        \"\\n\",\n        \"Burn rate: \",\n        burnRate,\n        \"\\n\",\n        \"Inflation: \",\n        inflation, \n        \"\\n\",\n        \"Utility: \",\n        utility,\n        \"\\n\",\n        \"Ecosystem size: \",\n        ecosystemSize,\n        \"\\n\",\n        \"Partnerships: \",\n        partnerships,\n        \"\\n\",\n        \"Regulation: \",\n        regulations,\n        \"\\n\",\n        \"Roadmap: \",\n        roadmap,\n        \"\\n\",\n        \"New Developments: \",\n        developments,\n        \"\\n\",\n        \"You must follow the following criteria: \\n\",\n        \"You need to impersonate 10 community members and you need to choose their characteristic traits (positive, negative, fudders, bullish, bearish, etc.) and create one message accordingly for each community member.\",\n        \"\\n\",\n        \"The messages should be within general community guidelines and should not include any obscene words\",\n        \"\\n\",\n        \"You dont need to label any message as created by any character, just make it look like a discord chat\",\n        \"\\n\",\n        \"Tell me in JSON format without the code block notation as follows:\"\n        \"\\n\",\n        '{ \\n',\n        '\"communityMessages\": [ \\n',\n        '\"...\", \"...\" \\n',\n        '] \\n',\n        '}'\n      );\n\n      return runAgent(query, 3);\n    }\n\n    function sentimentsForNewListing(\n      string memory projectName,\n      string memory projectDescription,\n      string memory totalSupply,\n      string memory tokenPrice,\n      string memory consensus,\n      string memory circulatingSupply,\n      string memory communitySize,\n      string memory marketCap,\n      string memory tradingVolume,\n      string memory priceVolatility,\n      string memory historicalPriceTrends,\n      string memory holderDistribution,\n      string memory burnRate,\n      string memory inflation,\n      string memory utility,\n      string memory ecosystemSize,\n      string memory partnerships,\n      string memory regulations,\n      string memory roadmap\n    ) public returns (uint i) {\n      string memory query = string.concat(\n        \"You are a helpful assistant who helps with the community's reactions on whether the token should be listed in the exchange. You need to behave in a way any general community member would behave given the information related to the protocol and the current market sentiments. \",\n        \"\\n\",\n        \"I will give you the following information - \\n\",\n        \"Name of the ICO project: \",\n        projectName,\n        \"\\n\",\n        \"Project description: \",\n        projectDescription,\n        \"\\n\",\n        \"The token total supply: \",\n        totalSupply,\n        \"\\n\",\n        \"Token price: \",\n\t\t\t  tokenPrice,\n        \"\\n\",\n        \"The token consensus: \",\n        consensus,\n        \"\\n\",\n        \"The token circulating supply in exchange: \",\n        circulatingSupply,\n        \"\\n\",\n        \"The token community size: \",\n        communitySize,\n        \"\\n\",\n        \"The token market cap: \",\n        marketCap,\n        \"\\n\",\n        \"Trading volume: \",\n        tradingVolume,\n        \"\\n\",\n        \"Price volatility: \",\n        priceVolatility,\n        \"\\n\",\n        \"Historical price trends: \",\n        historicalPriceTrends,\n        \"\\n\",\n        \"Holder distribution: \",\n        holderDistribution,\n        \"\\n\",\n        \"Burn rate: \",\n        burnRate,\n        \"\\n\",\n        \"Inflation: \",\n        inflation, \n        \"\\n\",\n        \"Utility: \",\n        utility,\n        \"\\n\",\n        \"Ecosystem size: \",\n        ecosystemSize,\n        \"\\n\",\n        \"Partnerships: \",\n        partnerships,\n        \"\\n\",\n        \"Regulation: \",\n        regulations,\n        \"\\n\",\n        \"Roadmap: \",\n        roadmap,\n        \"\\n\",\n        \"\\n\",\n        \"You must follow the following criteria: \\n\",\n        \"You need to impersonate 10 community members and you need to choose their characteristic traits (positive, negative, fudders, bullish, bearish, etc.) and create one message accordingly for each community member.\",\n        \"\\n\",\n        \"The messages should be within general community guidelines and should not include any obscene words\",\n        \"\\n\",\n        \"You dont need to label any message as created by any character, just make it look like a Discord chat\",\n        \"\\n\",\n        \"You can take into consideration the protocol developments shared in the past from the previous messages\",\n        \"\\n\",\n        \"You need to share an unbiased opinion of every community member on whether a token should be listed or not\",\n        \"\\n\",\n        \"Tell me in JSON format as follows:\",\n        \"\\n\",\n        '{ \\n',\n        '\"messages\": [ \\n',\n        '\"message1\", \"message2\" \\n',\n        '] \\n',\n        '}'\n      );\n\n      return runAgent(query, 3);\n    }\n\n    function runAgent(string memory query, uint8 max_iterations) public returns (uint i) {\n        AgentRun storage run = agentRuns[agentRunCount];\n\n        run.owner = msg.sender;\n        run.is_finished = false;\n        run.responsesCount = 0;\n        run.max_iterations = max_iterations;\n\n        Message memory systemMessage;\n        systemMessage.content = prompt;\n        systemMessage.role = \"system\";\n        run.messages.push(systemMessage);\n\n        Message memory newMessage;\n        newMessage.content = query;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n\n        uint currentId = agentRunCount;\n        agentRunCount = agentRunCount + 1;\n\n        IOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n        emit AgentRunCreated(run.owner, currentId);\n\n        return currentId;\n    }\n\n    function onOracleOpenAiLlmResponse(\n        uint runId,\n        IOracle.OpenAiResponse memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n\n        if (!compareStrings(errorMessage, \"\")) {\n            Message memory newMessage;\n            newMessage.role = \"assistant\";\n            newMessage.content = errorMessage;\n            run.messages.push(newMessage);\n            run.responsesCount++;\n            run.is_finished = true;\n            return;\n        }\n        if (run.responsesCount >= run.max_iterations) {\n            run.is_finished = true;\n            return;\n        }\n        if (!compareStrings(response.content, \"\")) {\n            Message memory assistantMessage;\n            assistantMessage.content = response.content;\n            assistantMessage.role = \"assistant\";\n            run.messages.push(assistantMessage);\n            run.responsesCount++;\n        }\n        run.is_finished = true;\n    }\n\n    function onOracleFunctionResponse(\n        uint runId,\n        string memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n        require(\n            !run.is_finished, \"Run is finished\"\n        );\n        string memory result = response;\n        if (!compareStrings(errorMessage, \"\")) {\n            result = errorMessage;\n        }\n        Message memory newMessage;\n        newMessage.role = \"user\";\n        newMessage.content = result;\n        run.messages.push(newMessage);\n        run.responsesCount++;\n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n    }\n\n    function getMessageHistoryContents(uint agentId) public view returns (string[] memory) {\n        string[] memory messages = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            messages[i] = agentRuns[agentId].messages[i].content;\n        }\n        return messages;\n    }\n\n    function getMessageHistoryRoles(uint agentId) public view returns (string[] memory) {\n        string[] memory roles = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            roles[i] = agentRuns[agentId].messages[i].role;\n        }\n        return roles;\n    }\n\n    function isRunFinished(uint runId) public view returns (bool) {\n        return agentRuns[runId].is_finished;\n    }\n\n    function compareStrings(string memory a, string memory b) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}"
    },
    "contracts/ExchangeAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract ExchangeAgent {\n\n    string public prompt;\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct AgentRun {\n        address owner;\n        Message[] messages;\n        uint responsesCount;\n        uint8 max_iterations;\n        bool is_finished;\n    }\n\n    mapping(uint => AgentRun) public agentRuns;\n    uint private agentRunCount;\n\n    event AgentRunCreated(address indexed owner, uint indexed runId);\n\n    address private owner;\n    address public oracleAddress;\n\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    IOracle.OpenAiRequest private config;\n\n    constructor(\n        address initialOracleAddress,         \n        string memory systemPrompt\n    ) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        prompt = systemPrompt;\n\n        config = IOracle.OpenAiRequest({\n            model : \"gpt-4-turbo-preview\",\n            frequencyPenalty : 21, // > 20 for null\n            logitBias : \"\", // empty str for null\n            maxTokens : 1000, // 0 for null\n            presencePenalty : 21, // > 20 for null\n            responseFormat : \"{\\\"type\\\":\\\"text\\\"}\",\n            seed : 0, // null\n            stop : \"\", // null\n            temperature : 10, // Example temperature (scaled up, 10 means 1.0), > 20 means null\n            topP : 101, // Percentage 0-100, > 100 means null\n            tools : \"[{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"web_search\\\",\\\"description\\\":\\\"Search the internet\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"query\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Search query\\\"}},\\\"required\\\":[\\\"query\\\"]}}},{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"image_generation\\\",\\\"description\\\":\\\"Generates an image using Dalle-2\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"prompt\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Dalle-2 prompt to generate an image\\\"}},\\\"required\\\":[\\\"prompt\\\"]}}}]\",\n            toolChoice : \"auto\", // \"none\" or \"auto\"\n            user : \"\" // null\n        });\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function TokenListingBehaviour(\n      string memory projectName,\n      string memory projectDescription,\n      string memory totalSupply,\n      string memory tokenPrice,\n      string memory consensus,\n      string memory circulatingSupply,\n      string memory communitySize,\n      string memory marketCap,\n      string memory tradingVolume,\n      string memory priceVolatility,\n      string memory historicalPriceTrends,\n      string memory holderDistribution,\n      string memory burnRate,\n      string memory inflation,\n      string memory utility,\n      string memory ecosystemSize,\n      string memory partnerships,\n      string memory communitySentiments,\n      string memory regulations,\n      string memory roadmap\n    ) public returns (uint i) {\n      string memory query = string.concat(\n        \"You are a helpful assistant that helps with the decision of the crypto exchange\",\n        \"\\n\",\n        \"I will give you the following information - \\n\",\n        \"Name of the ICO project: \",\n        projectName,\n        \"\\n\",\n        \"Project description: \",\n        projectDescription,\n        \"\\n\",\n        \"The token total supply: \",\n        totalSupply,\n        \"\\n\",\n        \"Token price: \",\n\t\t\t  tokenPrice,\n        \"\\n\",\n        \"The token consensus: \",\n        consensus,\n        \"\\n\",\n        \"The token circulating supply in exchange: \",\n        circulatingSupply,\n        \"\\n\",\n        \"The token community size: \",\n        communitySize,\n        \"\\n\",\n        \"The token market cap: \",\n        marketCap,\n        \"\\n\",\n        \"Trading volume: \",\n        tradingVolume,\n        \"\\n\",\n        \"Price volatility: \",\n        priceVolatility,\n        \"\\n\",\n        \"Historical price trends: \",\n        historicalPriceTrends,\n        \"\\n\",\n        \"Holder distribution: \",\n        holderDistribution,\n        \"\\n\",\n        \"Burn rate: \",\n        burnRate,\n        \"\\n\",\n        \"Inflation: \",\n        inflation, \n        \"\\n\",\n        \"Utility: \",\n        utility,\n        \"\\n\",\n        \"Ecosystem size: \",\n        ecosystemSize,\n        \"\\n\",\n        \"Partnerships: \",\n        partnerships,\n        \"\\n\",\n        \"Community Sentiments: \",\n        communitySentiments,\n        \"\\n\",\n        \"Regulation: \",\n        regulations,\n        \"\\n\",\n        \"Roadmap: \",\n        roadmap,\n        \"\\n\",\n        \"\\n\"\n        \"You must follow the following criteria: \",\n        \"\\n\",\n        \"You need to take a decision on the behalf of the exchange on whether you will be listing this token or not.\",\n        \"\\n\",\n        \"You need to take a decision on behalf of the exchange on how many of the tokens you will be listing and for how much price\",\n        \"\\n\",\n        \"Tell me in JSON format without the code block notation as follows:\",\n        \"\\n\",\n        '{ \\n',\n        '\"totalTokensListed\": \"...\", \\n',\n        '\"percentageOfTotalCirculatingSupplyListed\": \"...\", \\n',\n        '\"willYouListThisToken\": \"yes or no\", \\n',\n        '\"listingFees\": \"...\" \\n',\n        '}'\n      );\n\n      return runAgent(query, 3);\n    }\n\n    function runAgent(string memory query, uint8 max_iterations) public returns (uint i) {\n        AgentRun storage run = agentRuns[agentRunCount];\n\n        run.owner = msg.sender;\n        run.is_finished = false;\n        run.responsesCount = 0;\n        run.max_iterations = max_iterations;\n\n        Message memory systemMessage;\n        systemMessage.content = prompt;\n        systemMessage.role = \"system\";\n        run.messages.push(systemMessage);\n\n        Message memory newMessage;\n        newMessage.content = query;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n\n        uint currentId = agentRunCount;\n        agentRunCount = agentRunCount + 1;\n\n        IOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n        emit AgentRunCreated(run.owner, currentId);\n\n        return currentId;\n    }\n\n    function onOracleOpenAiLlmResponse(\n        uint runId,\n        IOracle.OpenAiResponse memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n\n        if (!compareStrings(errorMessage, \"\")) {\n            Message memory newMessage;\n            newMessage.role = \"assistant\";\n            newMessage.content = errorMessage;\n            run.messages.push(newMessage);\n            run.responsesCount++;\n            run.is_finished = true;\n            return;\n        }\n        if (run.responsesCount >= run.max_iterations) {\n            run.is_finished = true;\n            return;\n        }\n        if (!compareStrings(response.content, \"\")) {\n            Message memory assistantMessage;\n            assistantMessage.content = response.content;\n            assistantMessage.role = \"assistant\";\n            run.messages.push(assistantMessage);\n            run.responsesCount++;\n        }\n        run.is_finished = true;\n    }\n\n    function onOracleFunctionResponse(\n        uint runId,\n        string memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n        require(\n            !run.is_finished, \"Run is finished\"\n        );\n        string memory result = response;\n        if (!compareStrings(errorMessage, \"\")) {\n            result = errorMessage;\n        }\n        Message memory newMessage;\n        newMessage.role = \"user\";\n        newMessage.content = result;\n        run.messages.push(newMessage);\n        run.responsesCount++;\n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n    }\n\n    function getMessageHistoryContents(uint agentId) public view returns (string[] memory) {\n        string[] memory messages = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            messages[i] = agentRuns[agentId].messages[i].content;\n        }\n        return messages;\n    }\n\n    function getMessageHistoryRoles(uint agentId) public view returns (string[] memory) {\n        string[] memory roles = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            roles[i] = agentRuns[agentId].messages[i].role;\n        }\n        return roles;\n    }\n\n    function isRunFinished(uint runId) public view returns (bool) {\n        return agentRuns[runId].is_finished;\n    }\n\n    function compareStrings(string memory a, string memory b) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}"
    },
    "contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ninterface IOracle {\n\n    struct Content {\n        string contentType;\n        string value;\n    }\n\n    struct Message {\n        string role;\n        Content [] content;\n    }\n\n    struct OpenAiRequest {\n        // \"gpt-4-turbo\", \"gpt-4-turbo-preview\" or \"gpt-3.5-turbo-1106\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        // JSON list for tools in OpenAI format, empty for null, names have to match the supported tools\n        string tools;\n        // \"none\", \"auto\" or empty str which defaults to auto on OpenAI side\n        string toolChoice;\n        string user;\n    }\n\n    struct OpenAiResponse {\n        string id;\n\n        // either content is an empty srt or functionName and functionArguments\n        string content;\n        string functionName;\n        string functionArguments;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct GroqRequest {\n        // \"llama3-8b-8192\", \"llama3-70b-8192\", \"mixtral-8x7b-32768\" or \"gemma-7b-it\"\n        string model;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 frequencyPenalty;\n        // JSON string or empty string\n        string logitBias;\n        // 0 for null\n        uint32 maxTokens;\n        // int -20 - 20, Mapped to float -2.0 - 2.0. If bigger than 20 then null\n        int8 presencePenalty;\n        // JSON string or empty string\n        string responseFormat;\n        // 0 for null\n        uint seed;\n        // empty str for null\n        string stop;\n        // 0-20, > 20 for null\n        uint temperature;\n        // 0-100  percentage, > 100 for null\n        uint topP;\n        string user;\n    }\n\n    struct GroqResponse {\n        string id;\n\n        string content;\n\n        uint64 created;\n        string model;\n        string systemFingerprint;\n        // kind of pointless since its always \"chat.completion\"?\n        string object;\n\n        uint32 completionTokens;\n        uint32 promptTokens;\n        uint32 totalTokens;\n    }\n\n    struct KnowledgeBaseQueryRequest {\n        string cid;\n        string query;\n        uint32 num_documents;\n    }\n\n    function createLlmCall(\n        uint promptId\n    ) external returns (uint);\n\n    function createGroqLlmCall(\n        uint promptId,\n        GroqRequest memory request\n    ) external returns (uint);\n\n    function createOpenAiLlmCall(\n        uint promptId,\n        OpenAiRequest memory request\n    ) external returns (uint);\n\n    function createFunctionCall(\n        uint functionCallbackId,\n        string memory functionType,\n        string memory functionInput\n    ) external returns (uint i);\n\n    function createKnowledgeBaseQuery(\n        uint kbQueryCallbackId,\n        string memory cid,\n        string memory query,\n        uint32 num_documents\n    ) external returns (uint i);\n}"
    },
    "contracts/RetailInvestorAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract RetailInvestorAgent {\n\n    string public prompt;\n\n    struct Message {\n        string role;\n        string content;\n    }\n\n    struct AgentRun {\n        address owner;\n        Message[] messages;\n        uint responsesCount;\n        uint8 max_iterations;\n        bool is_finished;\n    }\n\n    mapping(uint => AgentRun) public agentRuns;\n    uint private agentRunCount;\n\n    event AgentRunCreated(address indexed owner, uint indexed runId);\n\n    address private owner;\n    address public oracleAddress;\n\n    event OracleAddressUpdated(address indexed newOracleAddress);\n\n    IOracle.OpenAiRequest private config;\n\n    constructor(\n        address initialOracleAddress,         \n        string memory systemPrompt\n    ) {\n        owner = msg.sender;\n        oracleAddress = initialOracleAddress;\n        prompt = systemPrompt;\n\n        config = IOracle.OpenAiRequest({\n            model : \"gpt-4-turbo-preview\",\n            frequencyPenalty : 21, // > 20 for null\n            logitBias : \"\", // empty str for null\n            maxTokens : 1000, // 0 for null\n            presencePenalty : 21, // > 20 for null\n            responseFormat : \"{\\\"type\\\":\\\"text\\\"}\",\n            seed : 0, // null\n            stop : \"\", // null\n            temperature : 10, // Example temperature (scaled up, 10 means 1.0), > 20 means null\n            topP : 101, // Percentage 0-100, > 100 means null\n            tools : \"[{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"web_search\\\",\\\"description\\\":\\\"Search the internet\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"query\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Search query\\\"}},\\\"required\\\":[\\\"query\\\"]}}},{\\\"type\\\":\\\"function\\\",\\\"function\\\":{\\\"name\\\":\\\"image_generation\\\",\\\"description\\\":\\\"Generates an image using Dalle-2\\\",\\\"parameters\\\":{\\\"type\\\":\\\"object\\\",\\\"properties\\\":{\\\"prompt\\\":{\\\"type\\\":\\\"string\\\",\\\"description\\\":\\\"Dalle-2 prompt to generate an image\\\"}},\\\"required\\\":[\\\"prompt\\\"]}}}]\",\n            toolChoice : \"auto\", // \"none\" or \"auto\"\n            user : \"\" // null\n        });\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Caller is not owner\");\n        _;\n    }\n\n    modifier onlyOracle() {\n        require(msg.sender == oracleAddress, \"Caller is not oracle\");\n        _;\n    }\n\n    function setOracleAddress(address newOracleAddress) public onlyOwner {\n        require(msg.sender == owner, \"Caller is not the owner\");\n        oracleAddress = newOracleAddress;\n        emit OracleAddressUpdated(newOracleAddress);\n    }\n\n    function TokenInvestBehaviour(\n      string memory projectName,\n      string memory projectDescription,\n      string memory totalSupply,\n      string memory tokenPrice,\n      string memory consensus,\n      string memory circulatingSupply,\n      string memory communitySize,\n      string memory marketCap,\n      string memory tradingVolume,\n      string memory priceVolatility,\n      string memory historicalPriceTrends,\n      string memory holderDistribution,\n      string memory burnRate,\n      string memory inflation,\n      string memory utility,\n      string memory ecosystemSize,\n      string memory partnerships,\n      string memory regulations,\n      string memory roadmap,\n      string memory newOutreach\n    ) public returns (uint i) {\n      string memory query = string.concat(\n        \"You are a helpful assistant that helps with the community joining and investment decisions in the crypto token. \\n\",\n        \"I will give you the following information - \\n\",\n        \"Name of the ICO project: \",\n        projectName,\n        \"\\n\",\n        \"Project description: \",\n        projectDescription,\n        \"\\n\",\n        \"The token total supply: \",\n        totalSupply,\n        \"\\n\",\n        \"Token price: \",\n\t\t\t  tokenPrice,\n        \"\\n\",\n        \"The token consensus: \",\n        consensus,\n        \"\\n\",\n        \"The token circulating supply in exchange: \",\n        circulatingSupply,\n        \"\\n\",\n        \"The token community size: \",\n        communitySize,\n        \"\\n\",\n        \"The token market cap: \",\n        marketCap,\n        \"\\n\",\n        \"Trading volume: \",\n        tradingVolume,\n        \"\\n\",\n        \"Price volatility: \",\n        priceVolatility,\n        \"\\n\",\n        \"Historical price trends: \",\n        historicalPriceTrends,\n        \"\\n\",\n        \"Holder distribution: \",\n        holderDistribution,\n        \"\\n\",\n        \"Burn rate: \",\n        burnRate,\n        \"\\n\",\n        \"Inflation: \",\n        inflation, \n        \"\\n\",\n        \"Utility: \",\n        utility,\n        \"\\n\",\n        \"Ecosystem size: \",\n        ecosystemSize,\n        \"\\n\",\n        \"Partnerships: \",\n        partnerships,\n        \"\\n\",\n        \"Regulation: \",\n        regulations,\n        \"\\n\",\n        \"Roadmap: \",\n        roadmap,\n        \"\\n\"\n        \"Total new users outreach: \",\n        newOutreach,\n        \"\\n\",\n        \"\\n\",\n        \"You must follow the following criteria:\",\n        \"\\n\",\n        \"You are among the new users being marketed choose whether you will join the community\",\n        \"\\n\",\n        \"You are among the new users being marketed choose whether you will purchase the token and how many tokens\",\n        \"\\n\",\n        \"You should tell me how many of the new users marketed will join the community\",\n        \"\\n\",\n        \"You should tell me how many of the new users marketed will purchase the token and how many of the tokens\",\n        \"\\n\",\n        \"You should tell me how the final community size, token holders size, token supply and token price will look like\",\n        \"\\n\",\n        \"Tell me in JSON format without the code block notation as follows:\",\n        \"\\n\",\n        \"{ \\n\",\n        '\"tokenPrice: \"...\", \\n',\n        '\"totalHolders\": \"...\", \\n',\n        '\"totalNewHolders\": \"...\" \\n',\n        '\"tokenSupply\": \"...\" \\n',\n        '\"communitySize\": \"...\"',\n        '\"newCommunityMembers\": \"...\"',\n        '}\"' \n      );\n\n      return runAgent(query, 3);\n    }\n\n    function runAgent(string memory query, uint8 max_iterations) public returns (uint i) {\n        AgentRun storage run = agentRuns[agentRunCount];\n\n        run.owner = msg.sender;\n        run.is_finished = false;\n        run.responsesCount = 0;\n        run.max_iterations = max_iterations;\n\n        Message memory systemMessage;\n        systemMessage.content = prompt;\n        systemMessage.role = \"system\";\n        run.messages.push(systemMessage);\n\n        Message memory newMessage;\n        newMessage.content = query;\n        newMessage.role = \"user\";\n        run.messages.push(newMessage);\n\n        uint currentId = agentRunCount;\n        agentRunCount = agentRunCount + 1;\n\n        IOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n        emit AgentRunCreated(run.owner, currentId);\n\n        return currentId;\n    }\n\n    function onOracleOpenAiLlmResponse(\n        uint runId,\n        IOracle.OpenAiResponse memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n\n        if (!compareStrings(errorMessage, \"\")) {\n            Message memory newMessage;\n            newMessage.role = \"assistant\";\n            newMessage.content = errorMessage;\n            run.messages.push(newMessage);\n            run.responsesCount++;\n            run.is_finished = true;\n            return;\n        }\n        if (run.responsesCount >= run.max_iterations) {\n            run.is_finished = true;\n            return;\n        }\n        if (!compareStrings(response.content, \"\")) {\n            Message memory assistantMessage;\n            assistantMessage.content = response.content;\n            assistantMessage.role = \"assistant\";\n            run.messages.push(assistantMessage);\n            run.responsesCount++;\n        }\n        run.is_finished = true;\n    }\n\n    function onOracleFunctionResponse(\n        uint runId,\n        string memory response,\n        string memory errorMessage\n    ) public onlyOracle {\n        AgentRun storage run = agentRuns[runId];\n        require(\n            !run.is_finished, \"Run is finished\"\n        );\n        string memory result = response;\n        if (!compareStrings(errorMessage, \"\")) {\n            result = errorMessage;\n        }\n        Message memory newMessage;\n        newMessage.role = \"user\";\n        newMessage.content = result;\n        run.messages.push(newMessage);\n        run.responsesCount++;\n        IOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n    }\n\n    function getMessageHistoryContents(uint agentId) public view returns (string[] memory) {\n        string[] memory messages = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            messages[i] = agentRuns[agentId].messages[i].content;\n        }\n        return messages;\n    }\n\n    function getMessageHistoryRoles(uint agentId) public view returns (string[] memory) {\n        string[] memory roles = new string[](agentRuns[agentId].messages.length);\n        for (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n            roles[i] = agentRuns[agentId].messages[i].role;\n        }\n        return roles;\n    }\n\n    function isRunFinished(uint runId) public view returns (bool) {\n        return agentRuns[runId].is_finished;\n    }\n\n    function compareStrings(string memory a, string memory b) private pure returns (bool) {\n        return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n    }\n}"
    },
    "contracts/TraderAgent.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Uncomment this line to use console.log\n// import \"hardhat/console.sol\";\nimport \"./interfaces/IOracle.sol\";\n\ncontract TraderAgent {\n\tstring public prompt;\n\n\tstruct Message {\n\t\tstring role;\n\t\tstring content;\n\t}\n\n\tstruct AgentRun {\n\t\taddress owner;\n\t\tMessage[] messages;\n\t\tuint responsesCount;\n\t\tuint8 max_iterations;\n\t\tbool is_finished;\n\t}\n\n\tmapping(uint => AgentRun) public agentRuns;\n\tuint private agentRunCount;\n\n\tevent AgentRunCreated(address indexed owner, uint indexed runId);\n\n\taddress private owner;\n\taddress public oracleAddress;\n\n\tevent OracleAddressUpdated(address indexed newOracleAddress);\n\n\tIOracle.OpenAiRequest private config;\n\n\tconstructor(address initialOracleAddress, string memory systemPrompt) {\n\t\towner = msg.sender;\n\t\toracleAddress = initialOracleAddress;\n\t\tprompt = systemPrompt;\n\n\t\tconfig = IOracle.OpenAiRequest({\n\t\t\tmodel: \"gpt-4-turbo-preview\",\n\t\t\tfrequencyPenalty: 21, // > 20 for null\n\t\t\tlogitBias: \"\", // empty str for null\n\t\t\tmaxTokens: 1000, // 0 for null\n\t\t\tpresencePenalty: 21, // > 20 for null\n\t\t\tresponseFormat: '{\"type\":\"text\"}',\n\t\t\tseed: 0, // null\n\t\t\tstop: \"\", // null\n\t\t\ttemperature: 10, // Example temperature (scaled up, 10 means 1.0), > 20 means null\n\t\t\ttopP: 101, // Percentage 0-100, > 100 means null\n\t\t\ttools: '[{\"type\":\"function\",\"function\":{\"name\":\"image_generation\",\"description\":\"Generates an image using Dalle-2\",\"parameters\":{\"type\":\"object\",\"properties\":{\"prompt\":{\"type\":\"string\",\"description\":\"Dalle-2 prompt to generate an image\"}},\"required\":[\"prompt\"]}}}]',\n\t\t\ttoolChoice: \"auto\", // \"none\" or \"auto\"\n\t\t\tuser: \"\" // null\n\t\t});\n\t}\n\n\tmodifier onlyOwner() {\n\t\trequire(msg.sender == owner, \"Caller is not owner\");\n\t\t_;\n\t}\n\n\tmodifier onlyOracle() {\n\t\trequire(msg.sender == oracleAddress, \"Caller is not oracle\");\n\t\t_;\n\t}\n\n\tfunction setOracleAddress(address newOracleAddress) public onlyOwner {\n\t\trequire(msg.sender == owner, \"Caller is not the owner\");\n\t\toracleAddress = newOracleAddress;\n\t\temit OracleAddressUpdated(newOracleAddress);\n\t}\n\n\tfunction ICOTradeBehaviour(\n\t\tstring memory projectName,\n\t\tstring memory projectDescription,\n\t\tstring memory totalSupply,\n\t\tstring memory teamAllocation,\n\t\tstring memory advisorAllocation,\n\t\tstring memory publicSaleAllocation,\n\t\tstring memory privateSaleAllocation,\n\t\tstring memory communityAllocation,\n\t\tstring memory futureDevAllocation,\n\t\tstring memory tokenPrice,\n\t\tstring memory hardCap,\n\t\tstring memory softCap,\n\t\tstring memory acceptedCrypto,\n\t\tstring memory consensus,\n\t\tstring memory circulatingSupply,\n\t\tstring memory communitySize,\n\t\tstring memory poolPercentage,\n\t\tstring memory liquidityPool\n\t) public returns (uint i) {\n\t\tstring memory query = string.concat(\n\t\t\t\"You are a helpful assistant that helps with the investment decision in a particular crypto token. \\n\",\n\t\t\t\"I will give you the following information -\\n\",\n\t\t\t\"Name of the ICO project: \",\n\t\t\tprojectName,\n\t\t\t\"\\n\",\n\t\t\t\"Project description: \",\n\t\t\tprojectDescription,\n\t\t\t\"\\n\",\n\t\t\t\"The token total supply: \",\n\t\t\ttotalSupply,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for founders/team: \",\n\t\t\tteamAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for advisors: \",\n\t\t\tadvisorAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for public sale: \",\n\t\t\tpublicSaleAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for private sale: \",\n\t\t\tprivateSaleAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for community/marketing: \",\n\t\t\tcommunityAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Allocation for future development: \",\n\t\t\tfutureDevAllocation,\n\t\t\t\"\\n\",\n\t\t\t\"Token price: \",\n\t\t\ttokenPrice,\n\t\t\t\"\\n\",\n\t\t\t\"Hard cap: \",\n\t\t\thardCap,\n\t\t\t\"\\n\",\n\t\t\t\"Soft cap: \",\n\t\t\tsoftCap,\n\t\t\t\"\\n\",\n\t\t\t\"Accepted cryptocurrencies for investment: \",\n\t\t\tacceptedCrypto,\n\t\t\t\"\\n\",\n\t\t\t\"The token consensus: \",\n\t\t\tconsensus,\n\t\t\t\"\\n\",\n\t\t\t\"The token circulating supply in exchange: \",\n\t\t\tcirculatingSupply,\n\t\t\t\"\\n\",\n\t\t\t\"The token community size: \",\n\t\t\tcommunitySize,\n\t\t\t\"\\n\",\n\t\t\t\"Pool percentage: \",\n\t\t\tpoolPercentage,\n\t\t\t\"\\n\",\n\t\t\t\"Liquidity Pool value: \",\n\t\t\tliquidityPool,\n\t\t\t\"\\n\",\n      \"\\n\",\n\t\t\t\"You must follow the following criteria: \\n\",\n\t\t\t\"You should choose the amount of tokens you want to buy according to the reasonable price you think an average crypto trader will buy for \\n\",\n\t\t\t\"You should tell me how many traders will buy this token at a similar price from the exchange as yours update the resulting price and total supply in the exchange \\n\",\n\t\t\t\"There should be no information about the operation, only the final JSON response. \\n\",\n\t\t\t\"Tell me in JSON format without the code block notation as follows: \\n\",\n\t\t\t\"{ \\n\",\n\t\t\t'\"tokenPrice: \"...\", \\n',\n\t\t\t'\"totalHolders\": \"...\", \\n',\n\t\t\t'\"tokenSupply\": \"...\" \\n',\n\t\t\t'}\"'\n\t\t);\n\n\t\treturn runAgent(query, 3);\n\t}\n\n\tfunction runAgent(\n\t\tstring memory query,\n\t\tuint8 max_iterations\n\t) public returns (uint i) {\n\t\tAgentRun storage run = agentRuns[agentRunCount];\n\n\t\trun.owner = msg.sender;\n\t\trun.is_finished = false;\n\t\trun.responsesCount = 0;\n\t\trun.max_iterations = max_iterations;\n\n\t\tMessage memory systemMessage;\n\t\tsystemMessage.content = prompt;\n\t\tsystemMessage.role = \"system\";\n\t\trun.messages.push(systemMessage);\n\n\t\tMessage memory newMessage;\n\t\tnewMessage.content = query;\n\t\tnewMessage.role = \"user\";\n\t\trun.messages.push(newMessage);\n\n\t\tuint currentId = agentRunCount;\n\t\tagentRunCount = agentRunCount + 1;\n\n\t\tIOracle(oracleAddress).createOpenAiLlmCall(currentId, config);\n\t\temit AgentRunCreated(run.owner, currentId);\n\n\t\treturn currentId;\n\t}\n\n\tfunction onOracleOpenAiLlmResponse(\n\t\tuint runId,\n\t\tIOracle.OpenAiResponse memory response,\n\t\tstring memory errorMessage\n\t) public onlyOracle {\n\t\tAgentRun storage run = agentRuns[runId];\n\n\t\tif (!compareStrings(errorMessage, \"\")) {\n\t\t\tMessage memory newMessage;\n\t\t\tnewMessage.role = \"assistant\";\n\t\t\tnewMessage.content = errorMessage;\n\t\t\trun.messages.push(newMessage);\n\t\t\trun.responsesCount++;\n\t\t\trun.is_finished = true;\n\t\t\treturn;\n\t\t}\n\t\tif (run.responsesCount >= run.max_iterations) {\n\t\t\trun.is_finished = true;\n\t\t\treturn;\n\t\t}\n\t\tif (!compareStrings(response.content, \"\")) {\n\t\t\tMessage memory assistantMessage;\n\t\t\tassistantMessage.content = response.content;\n\t\t\tassistantMessage.role = \"assistant\";\n\t\t\trun.messages.push(assistantMessage);\n\t\t\trun.responsesCount++;\n\t\t}\n\t\tif (!compareStrings(response.functionName, \"\")) {\n\t\t\tIOracle(oracleAddress).createFunctionCall(\n\t\t\t\trunId,\n\t\t\t\tresponse.functionName,\n\t\t\t\tresponse.functionArguments\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t\trun.is_finished = true;\n\t}\n\n\tfunction onOracleFunctionResponse(\n\t\tuint runId,\n\t\tstring memory response,\n\t\tstring memory errorMessage\n\t) public onlyOracle {\n\t\tAgentRun storage run = agentRuns[runId];\n\t\trequire(!run.is_finished, \"Run is finished\");\n\t\tstring memory result = response;\n\t\tif (!compareStrings(errorMessage, \"\")) {\n\t\t\tresult = errorMessage;\n\t\t}\n\t\tMessage memory newMessage;\n\t\tnewMessage.role = \"user\";\n\t\tnewMessage.content = result;\n\t\trun.messages.push(newMessage);\n\t\trun.responsesCount++;\n\t\tIOracle(oracleAddress).createOpenAiLlmCall(runId, config);\n\t}\n\n\tfunction getMessageHistoryContents(\n\t\tuint agentId\n\t) public view returns (string[] memory) {\n\t\tstring[] memory messages = new string[](\n\t\t\tagentRuns[agentId].messages.length\n\t\t);\n\t\tfor (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n\t\t\tmessages[i] = agentRuns[agentId].messages[i].content;\n\t\t}\n\t\treturn messages;\n\t}\n\n\tfunction getMessageHistoryRoles(\n\t\tuint agentId\n\t) public view returns (string[] memory) {\n\t\tstring[] memory roles = new string[](\n\t\t\tagentRuns[agentId].messages.length\n\t\t);\n\t\tfor (uint i = 0; i < agentRuns[agentId].messages.length; i++) {\n\t\t\troles[i] = agentRuns[agentId].messages[i].role;\n\t\t}\n\t\treturn roles;\n\t}\n\n\tfunction isRunFinished(uint runId) public view returns (bool) {\n\t\treturn agentRuns[runId].is_finished;\n\t}\n\n\tfunction compareStrings(\n\t\tstring memory a,\n\t\tstring memory b\n\t) private pure returns (bool) {\n\t\treturn (keccak256(abi.encodePacked((a))) ==\n\t\t\tkeccak256(abi.encodePacked((b))));\n\t}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}